---
title: "Monte Carlo Analysis for Verifying Expressions"
author: "Juri Trifonov"
output: html_document
---

## Core functions and packages
```{r}
rm(list = ls())
source("/Users/trifonovjuri/Desktop/sreg 2.0/code/fun.r")
library(sreg)
library(dplyr)
library(tidyr)
library(extraDistr)
```

## Individual level treatment assignment
Here we provide the results for the case with multiple treatments but without clusters (one covariate so far).

```{r}
nsim = 2000
tau_vec = c(0.5, 1.5)
n.treat = 2
k = 3
n = 1200
treat_sizes <- c(1, 1, 1)
theta_hat_mtrx <- matrix(ncol = n.treat, nrow = nsim)
v_hat_mtrx <- matrix(ncol = n.treat, nrow = nsim)
hit <- matrix(ncol = n.treat, nrow = nsim)

for (s in 1:nsim)
{
    data_raw <- dgp_po(n = n, theta.vec = tau_vec,  n.treat = n.treat, gamma.vec = c(0.4, 0.2, 1)) # Checked that now it returns several X's
    data_df <- run_experiment_multi(data_raw, n.treat = n.treat, k = k, treat_sizes = treat_sizes)      # 1 gets treatment 0, 1 gets treatment 1, 1 gets treatment 2 in each triplet
    data_full <- data.frame('Y' = data_df$y, 'D' = data_df$A, 'X' = data_df$X, 'S' = data_df$block)
    N = nrow(data_full)
    theta_hat_vec <- theta_hat_mult(data_full$Y, data_full$D, data_full$X, data_full$S)$tau.hat
    v_hat_vec <- var_hat_mult(data_full) / N
    theta_hat_mtrx[s, ] <- theta_hat_vec
    v_hat_mtrx[s, ] <- v_hat_vec
    upper  <- theta_hat_vec + qnorm(0.975) * sqrt(v_hat_vec)
    lower  <- theta_hat_vec - qnorm(0.975) * sqrt(v_hat_vec)
    hit[s, ] <- (theta.vec < upper) & (theta.vec > lower)
    print(s)

}
result_table <- data.frame(
  `True tau` = theta.vec,
  `E[tau_n]` = round(colMeans(theta_hat_mtrx), 4),
  `True Variance` = round(colMeans(v_hat_mtrx), 4),
  `E[V_n]` = round(apply(theta_hat_mtrx, 2, var), 4),
  `Coverage` = round(colMeans(hit), 4),
  check.names = FALSE
)
print(result_table)
```


## Cluster level treatment assignment
Here we provide the results for the case of cluster level treatment assignment with multiple treatments (one covariate so far).
```{r}
n_treat = 3
nsim = 10000
tau_vec = c(0.2, 1.2, 0.7)
gamma_vec = c(0.4, 0.2, 1)
tau_hat_mtrx <- matrix(ncol = n_treat, nrow = nsim)
var_hat_mtrx <- matrix(ncol = n_treat, nrow = nsim)
hit_mtrx     <- matrix(ncol = n_treat, nrow = nsim)
G    = 500
Nmax <- 50
k = 5
treat_sizes = c(2, 1, 1, 1) # treatment 0 - p_1 individuals, treatment 1 - p_2 individuals, ...
max.support <- Nmax / 10 - 1
#Ng <- rep(Nmax, G) 
Ng <- gen.cluster.sizes(G, max.support)

for (s in 1:nsim)
{
  data_pot            <- dgp.po.creg(Ng = Ng, tau.vec = tau_vec, G = G, gamma.vec = gamma_vec, n.treat = n_treat)
  proba               <- dgp.obs.creg(baseline = data_pot, n.treat = n_treat, k = k, treat_sizes = treat_sizes)
  data_cl             <- data.frame('Y' = proba$Y, 'D' = proba$D, proba$X, 'S' = proba$S, 'Ng' = proba$Ng, 'G.id' = proba$G.id)
  tau_hat             <- theta_hat_mult_cl(Y = data_cl$Y, D = data_cl$D, X = data_cl$x_1, S = data_cl$S, G.id = data_cl$G.id, Ng = data_cl$Ng)
  tau_hat_mtrx[s, ]   <- tau_hat$tau.hat
  var_hat             <- var_hat_mult_cl(Y = data_cl$Y, D = data_cl$D, X = data_cl$x_1, S = data_cl$S, G.id = data_cl$G.id, Ng = data_cl$Ng, tau.hat = tau_hat) / G
  var_hat_mtrx[s, ]   <- var_hat
  upper               <- tau_hat$tau.hat + qnorm(0.975) * sqrt(var_hat)
  lower               <- tau_hat$tau.hat - qnorm(0.975) * sqrt(var_hat)
  hit_mtrx[s, ]       <- (tau_vec < upper) & (tau_vec > lower)
  print(s)

}
result_table <- data.frame(
  `True tau` = tau_vec,
  `E[tau_n]` = round(colMeans(tau_hat_mtrx), 4),
  `E[V_n]` = round(colMeans(var_hat_mtrx), 4),
  `True Variance` = round(apply(tau_hat_mtrx, 2, var), 4),
  `Coverage` = round(colMeans(hit_mtrx), 4),
  check.names = FALSE
)
print(result_table)
``` 